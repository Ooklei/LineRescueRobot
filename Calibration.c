#pragma config(Sensor, S1,     lightRight,     sensorLightInactive)
#pragma config(Sensor, S2,     lightLeft,      sensorLightInactive)
#pragma config(Sensor, S3,     EV3SMUX,        sensorI2CCustom)
#pragma config(Sensor, S4,     portSplitter,   sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "common.h"
#include "mindsensors-ev3smux.h"
#include "NXTCamDriver.h"

#define LSA_I2C_ADDRESS 		0x14
#define LSA_CALIBRATED  		0x42

#define IMU_I2C_ADDRESS 		0x22
#define IMU_TILT_ALL_AXIS		0x42

int CalibrationTask = 1;

/***************************
EV3 Colour Sensors Variables
***************************/
tMSEV3 EV3Sensors[2];
tEV3SensorTypeMode typeMode[2] = {colorMeasureColor, colorMeasureColor};

/********************
Light Array Variables
********************/
byte LSA_I2CRequest[3] = {2, LSA_I2C_ADDRESS, LSA_CALIBRATED};
byte LSAReading[8];

/*****************
IMU Tilt Variables
*****************/
byte IMU_Y_TILT_I2CRequest[3] = {2, IMU_I2C_ADDRESS, IMU_TILT_ALL_AXIS};
byte TiltReading[3];

void lightSensors()
{
	//Turn on Red Light
	SensorType[lightRight] = sensorLightActive;
	SensorType[lightLeft] = sensorLightActive;

	//Display Values
	while(CalibrationTask == 1)
	{
		nxtDisplayCenteredBigTextLine(1, "R: %d", SensorValue(lightRight));
		nxtDisplayCenteredBigTextLine(4, "L: %d", SensorValue(lightLeft));
		//nxtDisplayCenteredTextLine(7, "CT: %d", CalibrationTask);
	}

	//Turn off Red Light
	SensorType[lightRight] = sensorLightInactive;
	SensorType[lightLeft] = sensorLightInactive;
}

void ChangeSensorMode(tEV3SensorTypeMode mode)
{
	for(int i = 0; i < 2; i++)
	{
		typeMode[i] = mode;
	}
	initSensor(&EV3Sensors[0], msensor_S3_2, typeMode[0]);
	initSensor(&EV3Sensors[1], msensor_S3_3, typeMode[1]);
}

void EV3SensorReadings()
{
	//Turn on Sensor to light mode
	ChangeSensorMode(colorReflectedLight);

	int ModeChanger = 0;
	tEV3SensorTypeMode SensorModes[2] = {colorReflectedLight, colorMeasureColor};
	while(CalibrationTask == 2)
	{
		if(nNxtButtonPressed == 3) //Change Sensor Mode
		{
			ModeChanger = 1 - ModeChanger;

			ChangeSensorMode(SensorModes[ModeChanger]);
			wait1Msec(300);
		}

		//Read EV3 Sensor Values
		for(int i = 0; i < 2; i++)
		{
			if(!readSensor(&EV3Sensors[i])) //EV3 SMUX I2C error fix
			{
				eraseDisplay();
				nxtDisplayCenteredTextLine(3, "Fixing SMUX");

				//Reset Port
				SensorType[EV3SMUX] = sensorLightInactive;
				wait1Msec(100);
				SensorType[EV3SMUX] = sensorI2CCustom;

				//Clear error state with bytes
				clearI2CError(S3, MSEV3_I2C_ADDR_CHAN2);
				clearI2CError(S3, MSEV3_I2C_ADDR_CHAN3);

				eraseDisplay();
			}
		}

		switch(ModeChanger) //Display values
		{
		case 0:
			nxtDisplayCenteredTextLine(1, "Light");
			nxtDisplayCenteredTextLine(3, "Left: %d", EV3Sensors[1].light);
			nxtDisplayCenteredTextLine(4, "Right: %d", EV3Sensors[0].light);
			//nxtDisplayCenteredTextLine(7, "L: %d", CalibrationTask);
			break;

		case 1:
			nxtDisplayCenteredTextLine(1, "Colour");
			nxtDisplayCenteredTextLine(3, "Left: %d", EV3Sensors[1].color);
			nxtDisplayCenteredTextLine(4, "Right: %d", EV3Sensors[0].color);
			//nxtDisplayCenteredTextLine(7, "CT: %d", CalibrationTask);
			break;
		}
	}
	//Turn off Sensor
	ChangeSensorMode(colorAmbientLight);
}

void LightSensorsArray()
{
	sendI2CMsg(portSplitter, &LSA_I2CRequest[0], 8);
	while(nI2CStatus[S4] == STAT_COMM_PENDING) {
		wait1Msec(2);
	}

	memset(LSAReading, 0, 8);
	if(nI2CStatus[portSplitter] != ERR_COMM_BUS_ERR)
	{
		readI2CReply(portSplitter, &LSAReading[0], 8);

		for(int i = 0; i < 8; i++)
		{
			nxtDisplayCenteredTextLine(i, "%d: %d", i, LSAReading[i]);
		}
	}
	else
	{
		eraseDisplay();
		nxtDisplayCenteredTextLine(3, "Fixing LSA");

		//Reset Port
		SensorType[portSplitter] = sensorLightInactive;
		wait1Msec(100);
		SensorType[S4] = sensorI2CCustom;

		//Clear error state with dummy bytes
		clearI2CError(portSplitter, LSA_I2C_ADDRESS);
		eraseDisplay();
	}
}

void IMU_Tilt()
{
	sendI2CMsg(S4, &IMU_Y_TILT_I2CRequest[0], 3);
	while(nI2CStatus[S4] == STAT_COMM_PENDING) {
		wait1Msec(2);
	}

	memset(TiltReading, 0, 3);
	if(nI2CStatus[portSplitter] != ERR_COMM_BUS_ERR)
	{
		readI2CReply(portSplitter, &TiltReading[0], 3);

		float angle = 0;
		if(TiltReading[1] != 0)
		{
			angle = radiansToDegrees(asin((126 - abs(TiltReading[1])) / 126.0000)) * (TiltReading[1]/abs(TiltReading[1]));
		}

		nxtDisplayCenteredTextLine(1, "Y Tilt",);
		nxtDisplayCenteredTextLine(4, "Y: %d", TiltReading[1]);
		nxtDisplayCenteredTextLine(7, "angle: %f", angle);
	}
	else
	{
		eraseDisplay();
		nxtDisplayCenteredTextLine(3, "Fixing IMU");

		//Reset Port
		SensorType[portSplitter] = sensorLightInactive;
		wait1Msec(100);
		SensorType[S4] = sensorI2CCustom;

		//Clear error state with dummy bytes
		clearI2CError(portSplitter, IMU_I2C_ADDRESS);
		eraseDisplay();
	}
}

task ProgramChanger()
{
	while(true)
	{
		if(nNxtButtonPressed != -1)
		{
			if(nNxtButtonPressed == 1) //Right Button
			{
				CalibrationTask += 1;
			}
			else if(nNxtButtonPressed == 2) //Left Button
			{
				CalibrationTask -= 1;
			}
			wait1Msec(500);
			eraseDisplay();
		}
	}
}

void CameraReading()
{
	numBlobs = countBlobs();
	mergeBlobs();

	for(int i = 0; i < 8; i++)
	{
		nxtDisplayTextLine(i, "%d", blobs[i].area);
	}

	if(ballDetected())
	{
		playSound(soundBlip);
	}
}

void initSensors() //Activate Sensors ready for reading
{
	nI2CBytesReady[EV3SMUX] = 0;
	nI2CBytesReady[portSplitter] = 0;

	while(nI2CStatus[EV3SMUX] == STAT_COMM_PENDING || nI2CStatus[S4] == STAT_COMM_PENDING) {
		wait1Msec(5);
	}
	ChangeSensorMode(colorMeasureColor);

	//Set NXT cam to line tracking
	initCamera();
}


task main()
{
	initSensors();
	startTask(ProgramChanger);
	motor[motorB] = 5;
	motor[motorC] = 5;
	stopAllMotors();
	while(true)
	{
		switch(CalibrationTask)
		{
		case 1:
			lightSensors();
			break;

		case 2:
			EV3SensorReadings();
			break;

		case 3:
			LightSensorsArray();
			break;

		case 4:
			IMU_Tilt();
			break;

		case 5:
			CameraReading();
			break;

		default:
			CalibrationTask = abs(5 - CalibrationTask);
			nxtDisplayCenteredTextLine(5, "fixing");
		}
	}
}
